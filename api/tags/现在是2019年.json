{"name":"现在是2019年","slug":"现在是2019年","count":1,"posts":[{"title":"我个人博客的第一篇博客","slug":"我个人博客的第一篇博客","date":"2019-04-03T13:01:15.000Z","updated":"2019-04-17T05:26:16.035Z","comments":true,"pin":null,"path":"api/articles/我个人博客的第一篇博客.json","excerpt":"","keywords":null,"cover":"https://i.loli.net/2019/04/17/5cb6b8e6e0bc7.png","content":"<h1 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h1><p>　　编译器的第一个工作阶段叫作分词，就是把由字符组成的字符串分解成词法单元。这个概念是理解词法作用域的基础</p>\n<p>　　简单地说，词法作用域就是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变</p>\n<p><strong>关系</strong></p>\n<p>　　无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function bar(c) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        console.log( a, b, c );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bar(b * 3);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo( 2 ); // 2 4 12</span><br></pre></td></tr></table></figure></div>\n<p>　　在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡</p>\n<p><img src=\"https://i.loli.net/2019/04/17/5cb6b8e6e0bc7.png\"></p>\n<p>　　作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的</p>\n<p>　　气泡1包含着整个全局作用域，其中只有一个标识符：foo</p>\n<p>　　气泡2包含着foo所创建的作用域，其中有三个标识符：a、bar和b</p>\n<p>　　气泡3包含着bar所创建的作用域，其中只有一个标识符：c</p>\n<p><strong>查找</strong></p>\n<p>　　作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置</p>\n<p>　　在代码片段中，引擎执行console.log(…)声明，并查找a、b和c三个变量的引用。它首先从最内部的作用域，也就是bar(…)函数的作用域开始查找。引擎无法在这里找到a，因此会去上一级到所嵌套的foo(…)的作用域中继续查找。在这里找到了a，因此引擎使用了这个引用。对b来讲也一样。而对c来说，引擎在bar(…)中找到了它</p>\n<p>　　[注意]词法作用域查找只会查找一级标识符，如果代码引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则分别接管对bar和baz属性的访问</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>foo = {</p>\n<pre><code>bar:{\n\n    baz: 1\n\n}\n</code></pre><p>};</p>\n<p>console.log(foo.bar.baz);//1</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p><strong>遮蔽</strong></p>\n<p>　　作用域查找从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止</p>\n<p>　　在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”，内部的标识符“遮蔽”了外部的标识符</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>var a = 0;</p>\n<p>function test(){</p>\n<pre><code>var a = 1;\n\nconsole.log(a);//1\n</code></pre><p>}</p>\n<p>test();</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>　　全局变量会自动为全局对象的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>var a = 0;</p>\n<p>function test(){</p>\n<pre><code>var a = 1;\n\nconsole.log(window.a);//0\n</code></pre><p>}</p>\n<p>test();</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到</p>\n<h1 id=\"作用域链的组成\"><a href=\"#作用域链的组成\" class=\"headerlink\" title=\"作用域链的组成\"></a>作用域链的组成</h1><p>   在JS中，函数的可以允许嵌套的。即，在一个函数的内部声明另一个函数</p>\n<pre><code>类似这样： \n</code></pre><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A()&#123;</span><br><span class=\"line\">  var  a=1;</span><br><span class=\"line\">   function B()&#123;  //在A函数内部，声明了函数B，这就是所谓的函数嵌套。</span><br><span class=\"line\">         var b=2;   </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>   对于A来说，A函数在执行的时候，会创建其A函数的作用域， 那么函数B在创建的时候，会引用A的作用域，类</p>\n<p>函数B在执行的时候，其作用域类似于下面这样：</p>\n<p><img src=\"https://images0.cnblogs.com/blog2015/697856/201504/071952581338727.png\"></p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image007.png\" alt=\"说明: https://images0.cnblogs.com/blog2015/697856/201504/071955114772258.png\"></p>\n<pre><code>从上面的两幅图中可以看出，函数B在执行的时候，是会引用函数A的作用域的。所以，像这种函数作用域的嵌套就组成了所谓的函数作用域链。当在自身作用域内找不到该变量的时候，会沿着作用域链逐步向上查找，若在全局作用域内部仍找不到该变量，则会抛出异常。\n</code></pre><h1 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h1><p><strong>JavaScript**</strong>解析机制是什么？</p>\n<p>　　JavaScript解析过程分为两个阶段，一个是编译阶段，另外一个就是执行阶段。</p>\n<p>　　<strong>*</strong> <strong>编译阶段</strong></p>\n<pre><code>   　　编译阶段就是我们常说的JavaScript预解析（预处理）阶段，在这个阶段JavaScript解释器将完成把JavaScript脚本代码转换到字节码。\n</code></pre><p>　　<strong>*</strong> <strong>执行阶段</strong></p>\n<p>　　　　在编译阶段JavaScript解释器借助执行环境把字节码生成机械码，并顺序执行。</p>\n<p><strong>编译阶段（预解析阶段）做什么操作？</strong></p>\n<p>　　<strong>* var , function**</strong>声明的变量提升**</p>\n<p>　　　　首先，创建一个当前执行环境下的活动对象，然后将用 <strong>var</strong> <strong>声明的变量</strong>设置为活动对象的属性（也就是将其添加到活动对象当中）并将其赋值为undefined，然后将 <strong>function</strong> <strong>定义的函数</strong> 也添加到活动对象当中。</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p>1 if( false ){</p>\n<p>2     var aa = 20;</p>\n<p>3     var bb = 30;</p>\n<p>4 }</p>\n<p>5 </p>\n<p>6 function AA(){};</p>\n<p>7 function BB(){};</p>\n<p>8 </p>\n<p>9 //var定义的aa,bb以及function定义的AA(),BB()都会被变量提升到window对象下面</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>   　<strong>*</strong> <strong>函数声明与函数表达式在预解析的区别</strong></p>\n<p>　　　　首先，我们知道解析器会对function定义的函数（也就是函数声明）在代码开始执行之前对其实行函数声明提升（function declaration hoisting），所以在函数声明之前调用该函数是不会在执行期间报错，但是函数表达式不同，函数表达式用 var 声明，也就是说解析器会对其变量提升，并对其赋值为undefined，然后在执行期间，等到执行到该var 变量的时候再将其变量指向一个function函数，所以在函数表达式之前执行该函数是会报错的。</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p>1 AA();</p>\n<p>2 function AA(){};</p>\n<p>3 </p>\n<p>4 BB();</p>\n<p>5 var BB = function(){};</p>\n<p>6 </p>\n<p>7 //AA();不会报错，因为是以function的变量提升，BB()会报错，因为是以var的变量提升，到其相当于 BB(); var BB = undefined; BB = function(){};</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>　　<strong>* function</strong> <strong>覆盖</strong></p>\n<p>　　　　若定义了两个同名的函数，则在预解析期间后面一个会覆盖签名一个</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p>1 AA();   // 输出 I am AA_2;</p>\n<p>2 function AA(){</p>\n<p>3    console.log(‘I am AA_1’);</p>\n<p>4 };</p>\n<p>5 </p>\n<p>6 AA();  // 输出 I am AA_2;</p>\n<p>7 function AA(){</p>\n<p>8   console.log(‘I am AA_2’);</p>\n<p>9 }</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>　　* <strong>预解析把变量或函数解析到其运行时的环境中</strong></p>\n<p>　　　　解析器将变量提升并不是将所有的变量都提升到window对象下面，其提升的原则是提升到变量运行的环境中去。</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p> 1 aa = “I am aa”;</p>\n<p> 2 (function(){</p>\n<p> 3     console.log(aa);  // 输出 aa 是 undefined</p>\n<p> 4     var aa = “I am aa in a function”;</p>\n<p> 5     console.log(aa);  //输出 aa 是 I am aa in a function</p>\n<p> 6 })();</p>\n<p> 7 </p>\n<p> 8 // 这里 aa 被变量提升，但是aa 没有被变量提升到 window下面，而是被提升到其运行的环境 (function(){ })() 中去，也就是等同于</p>\n<p> 9 </p>\n<p>10 // aa =  “I am aa”;</p>\n<p>11 //(function(){</p>\n<p>12 //    var aa;  </p>\n<p>13 //    console.log(aa);  // 输出 aa 是 undefined</p>\n<p>14 //    aa = “I am aa in a function”;</p>\n<p>15 //    console.log(aa);  //输出 aa 是 I am aa in a function</p>\n<p>16 //})();</p>\n<p>17 </p>\n<p>18 </p>\n<p>19 </p>\n<p>20 // 下面代码等同于上面，目的是为了若看不懂上面，则可看下面。</p>\n<p>21 aa = “I am aa”;</p>\n<p>22 function AA(){</p>\n<p>23     console.log(aa);</p>\n<p>24     var aa = “I am aa in a function”;</p>\n<p>25     console.log(aa);</p>\n<p>26 }</p>\n<p>27 AA();</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"noopener\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p>　　<strong>* JavaScript“**</strong>预解析<strong><strong>”</strong></strong>分段进行**</p>\n<p>　　　　所谓分段进行是按照<script>标签来分块进行预解析</p>\n<p><a href=\"javascript:void(0\"><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></a>;)</p>\n<p><img src=\"file:///C:\\Users\\student\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image001.gif\" alt=\"说明: 复制代码\"></p>\n<p> 1 <script></p>\n<p> 2 AA();  // 输出 AA2;</p>\n<p> 3 function AA(){</p>\n<p> 4    console.log(‘AA1’);</p>\n<p> 5 }</p>\n<p> 6 </p>\n<p> 7 function AA(){</p>\n<p> 8    console.log(‘AA2’);</p>\n<p> 9 }</p>\n<p>10 </script></p>\n<p>11 </p>\n<p>12 </p>\n<p>13 <script></p>\n<p>14 function AA(){</p>\n<p>15    console.log(‘AA3’);</p>\n<p>16 }</p>\n<p>17 </script></p>\n<p>18 </p>\n<p>19 //上面例子说明function函数声明是分块的，然而至于var变量的提升经过反复验证是不分块的</p>\n","text":"词法作用域　　编译器的第一个工作阶段叫作分词，就是把由字符组成的字符串分解成词法单元。这个概念是理解词法作用域的基础　　简单地说，词法作用域就是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变关系　　无论函数在哪里被","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"现在是2019年","slug":"现在是2019年","count":1,"path":"api/tags/现在是2019年.json"}]}]}